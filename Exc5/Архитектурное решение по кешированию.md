### Мотивация

Кэширование имеет смысл внедрить в тех частях/сущностях системы, к которым часто обращаются и которые не так часто меняются:

- Список заказов в CRM и MES (по крайней мере в течение дня он не будет интенсивно меняться).
- Статусы заказов: меняются нечасто, часто запрашиваются как операторами, так и клиентами
- Результаты расчёта стоимости изделий для часто используемых 3D-моделей (какие-нибудь популярные модели на свадьбу, День святого Валентина и т.д.)

Почему нужно внедрить кэширование?
- Кэширование снизит количество запросов к базе данных, что уменьшит нагрузку на неё и улучшит производительность.
- Кэширование часто запрашиваемых данных (например, списка заказов, статусов) ускорит время отклика системы для операторов и клиентов.
- Кэширование результатов расчёта стоимости в MES уменьшит время обработки запросов и затраты на ресурсы CPU.
- Быстрый доступ к данным повысит удовлетворённость клиентов и операторов.

Какие проблемы решит кэширование?
- Медленная загрузка списка заказов.
- Задержки при расчёте стоимости в MES.
- Медленное обновление статусов заказов.


### Предлагаемое решение

#### Способ кэширования
Выбираем серверное кэширование - оно позволяет централизованно управлять кэшем, что упрощает его обновление и инвалидацию.
Клиентское не подходит, так как данные довольно часто обновляются (например, статусы заказов), и синхронизация между клиентами будет сложной.

Так как у нас приложение, в котором присутствуют активные операции и чтения, и записи (клиенты оформляют заказы, а операторы их принимают),
можно использовать комбинированный подход Read-Through + Write-Behind.

Read-Through подойдет, потому что снижает вероятность ошибок, ведь обновление кэша - ответственность базы данных. 
А минус этого подхода - кэш-промах при первом запросе - можно решить прогревом кэша.

Write-Behind подойдет, так как он обеспечивает консистентность данных между кешем и базой. Это важно для операторов и клиентов,
чтобы список заказов и их статусы обновлялись в соответствии с БД. Благодаря асинхронности передачи
данных в бд, клиенты и операторы не будут ждать, пока данные запишутся в базу.

Диаграмма для получения списка заказов (Read-Through):

```
Клиент -> Сервер: Запрос списка заказов
Сервер -> Кэш: Запрос данных (ключ: "order_list")
alt Данные есть в кэше
    Кэш -> Сервер: Возврат данных
    Сервер -> Клиент: Возврат данных
else Данных нет в кэше
    Кэш -> База данных: Запрос данных
    База данных -> Кэш: Возврат данных
    Кэш -> Сервер: Возврат данных
    Сервер -> Клиент: Возврат данных
end
```

Диаграмма для обновления статуса заказа (Write-Behind)

```
Клиент -> Сервер: Запрос на обновление статуса заказа (order_id=123, status="В обработке")
Сервер -> Кэш: Запись нового статуса (ключ: "order_status_123", значение: "В обработке")
Кэш -> Сервер: Подтверждение записи
Сервер -> Клиент: Подтверждение обновления статуса
Кэш -> База данных: Асинхронное обновление статуса (order_id=123, status="В обработке")
База данных -> Кэш: Подтверждение обновления
```

#### Инвалидация
Подойдет нвалидация кэша на основе изменений (добавили новый заказ - обновили кеш. Взяли в работу - обновили).
Также подойдет инвалидация по ключу - для изменения кеша для отдельного заказа.